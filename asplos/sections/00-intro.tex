\section{Introduction}\label{sec:intro}
Given the complexity of modern electronic systems, a high degree of automation
is required to develop custom hardware within sensible timelines. At the
highest level, FPGA and ASIC design flows can be split into logical synthesis
and physical synthesis (optimize timing, placement and routing, etc..). This
division of work produces suboptimal designs, and neither are the individual
synthesis steps locally optimal on their own. However, logic minimization
problems in general are NP-Hard~\cite{logicmin,twolevellogic}, and modern EDA
flows bring compile times down to the human timescale while maintaining
acceptable QoR (quality of results).

With the end of Moore's Law scaling, chip area becomes a tighter constraint,
and logic synthesis is more of a bottleneck. Hence, future synthesis tools will
need to expand the design spaces they explore and find more optimal solutions.
Nonetheless, finding provably optimal circuits is computationally intractable.
In this paper, we will introduce how FPGA technology mapping can be augmented
with e-graph data structures to find \textit{more} exact solutions, without
significantly increasing compile times.

Technology mapping is the hand-off between logical synthesis and physical
synthesis. It converts the abstract Boolean logic into a network of gates that
belong to the target cell library. For FPGAs, the primary target cell is the
LUT (lookup table). Since every $k$-LUT can be re-programmed to satisfy any $k$
input boolean function, FPGA technology mapping has an unmistakably large
solution space. Whether the circuit is optimized for latency or area, most FPGA
tools approach technology mapping as a graph covering problem~\cite{flowmap,
    daomap, attmap, imap}. In the literature, a group of circuit nodes implemented
by a $k$-LUT is called a $k$-feasible cut of logic, and the generation of all
cuts is called cut enumeration. These structural mapping techniques
fundamentally rely on the topology of the input circuit. Hence, they are prone
to structural bias.

In contrast, functional mappers attempt to decompose Boolean functionality into
smaller sub-functions which can be realized by $k$-LUTs. Such mappers are a
more exact approach, and often use SAT solvers~\cite{satmap,satmap2} to drive
synthesis. However, exact synthesis tools cannot be scaled past tens of gates.
As a consequence, cut enumeration and functional mapping lie on two different
extremes. The former is faster but limited by the input structure, while the
latter is unbiased but fundamentally unscalable.

For this reason, we propose an e-graph driven technology mapper than can better
span the time-QoR spectrum. E-graphs are a data structure which use union-find
operations to compactly represent abstract equivalence relations. E-graphs are
useful as an optimizing compiler framework, because terms can be iteratively
rewritten in a nondestructive fashion. Instead of an optimization pass
architecture, e-graph driven compilers store all transformed terms in parallel
and defer selection of the best one. Our work seeks to evaluate the suitability
of e-graphs for logic synthesis, specifically technology mapping to FPGAs.

We introduce \shortname{}: a tool for repacking FPGA netlists into more compact
forms---without increasing circuit depth. Our results show many benchmarks, big
and small, which synthesize to significantly fewer LUTs over vendor EDA tools.
To that end, our work makes the following contributions:

\begin{itemize}
    \item We formulate an intermediate language and generating set of e-graph rewrite
          rules, as well as justify the types of circuit topologies that are reachable
          under composition.
    \item We evaluate our compiler against 96 benchmarks combined from three sources:
          EPFL~\cite{epflbench}, ISCAS'85~\cite{iscasbench}, and
          LGSynth'91~\cite{lgsynthbench}.
    \item \shortname{} is packaged as a Verilog-to-Verilog tool that can be dropped into existing RTL flows.
\end{itemize}

Before elaborating on our methodology and experimental setup, we first discuss
related ideas in technology mapping and e-graph driven compilers. Then, the
results section illustrates the typical reduction in LUT count our tool
achieves without increasing circuit depth. Lastly, we discuss the future work
of our compiler.