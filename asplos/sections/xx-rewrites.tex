\section{E-Graph Construction}\label{sec:rewrites}
\todo{intro the section}
\subsection{Simplifying Degenerate LUTs}\label{sec:rewrites:degen}

\textbf{Definition:} A LUT's configuration $F : \Bk \rightarrow \B$ is \textit{degenerate} if there exists a Shannon expansion $F = x_i \cdot F_{x_i} + \overline{x_i} \cdot F_{\overline{x}_i}$
such that $F_{x_i} = F_{\overline{x}_i}$ for some $i \in \{ 0, \ldots, k -1\}$. In other words, $F = F_{x_i} = F_{\overline{x}_i}$.

The output of a degenerate LUT is not dependent on one of its inputs. Hence, it
can be rewritten into a LUT which uses fewer inputs. This rule is applied by
computing the Shannon expansions of LUTs and checking for equivalence.

\begin{verbatim}
    (LUT F x0 x1 x2) => (LUT F' x0 x1)
        if F(x0, x1, 0) == F(x0, x1, 1)
        where F'(x0, x1) := F(x0, x1, 0)
\end{verbatim}

A separate rule is instantiated for every LUT size and every input position. In
total, $\sum_{k=1}^{6} k = 6(6+1)/2 = 21$ rules are instantiated for searching
for degenerate LUTs. Since this rule is computationally expensive, it is
applied greedily as a pre-processing step before the e-graph is built. None of
the other rewrite rules create degenerate LUTs, so this has no impact on
results. Of course this rule can be enabled at any time, if it were necessary.

\subsection{Functional Composition}\label{sec:rewrites:composition}

\subsection{LUT Symmetries}\label{sec:rewrites:symmetry}

The semantics of LUTs should not depend on the order of their inputs. If two
LUTs have permuted inputs but are otherwise functionally identical, they should
be present in the same e-class in the graph. That is, \mbox{\texttt{(LUT F ..
        xi .. xj ..)}} is semantically equivalent to \mbox{\texttt{(LUT G .. xj .. xi
        ..)}} if and only if $G = F \odot \sigma^{-1}$, where $\sigma \in S_k$ is the
permutation applied to the inputs.

\begin{proof}
    $\odot$ is a right-action defined for the sake of permuting the inputs to a function before they are applied:
    \[ \odot : \big (\Bk \rightarrow \mathbb{Z}_2 \big ) \times S_k \rightarrow \big (\Bk \rightarrow \mathbb{Z}_2 \big )\]
    \[ F \odot \sigma : (x_0, x_1, \ldots, x_{k-1}) \mapsto F(x_{\sigma(0)}, x_{\sigma(1)}, \ldots, x_{\sigma(k-1)}) \]

    It is trivial to prove that this right-action is associative:
    \begin{align*}
        (F \odot \sigma_1) \odot \sigma_2 & = F(x_{\sigma_2(\sigma_1(0))}, x_{\sigma_2(\sigma_1(1))}, \ldots, x_{\sigma_2(\sigma_1(k-1))}) \\
        (F \odot \sigma_1) \odot \sigma_2 & = F \odot (\sigma_2 \circ \sigma_1)
    \end{align*}
    With this property, the rest follows directly:
    \[ F = G \odot
        \sigma \iff F \odot \sigma^{-1} = (G \odot \sigma) \odot \sigma^{-1} = G \]
\end{proof}

Therefore, we can conclude that $k$-LUTs have as much symmetry as can be
generated by the group $S_k$. This formal approach may be considered overkill.
However, it precisely reveals how many e-graph rewrite rules need to generate
all the symmetries of a LUT. For any $k$-LUT with program $F$, we need as many
rules as it takes to generate $F \odot S_k$. It is a well-known fact that that
the $k-1$ adjacent transpositions generate $S_k$~\cite{sgroup}. Therefore, we
can program an e-graph rewrite rule for each adjacent transposition. In total,
this is $\sum_{k=2}^{6} (k-1) = 15$ rules.

\subsection{LUTs with Domain Restrictions}\label{sec:rewrites:restrict}

\textbf{Definition:} A lookup table \texttt{(LUT F x0 x1 ...)} is \textit{restricted} if \texttt{xi == xj} for some $ i, j \in \{0, \ldots, k-1\}, \; i \neq j$.
In other words, the domain of the LUT is restricted.

The main advantage of using e-graphs is the compact way in which it represents
notions of equality. When considering the entire set of rewrite rules under
composition, we can observe new equalities being formed in the e-graph.
Whenever an equality is found between two of the inputs to a $k$-LUT, it can be
rewritten with a $(k-1)$-LUT. We simply need to define and compute
$\texttt{restrict(F, i, j)}$ which maps $F : \Bx{k} \rightarrow \B$ to the
domain-restricted $F \vert_{x_i = x_j} : \Bx{k-1} \rightarrow \B$. In
pseudocode, the rewrite rule can be rwritten as follows:

\begin{verbatim}
    (LUT F x0 x1 x0) => (LUT G x0 x1)
        where G := restrict(F, 0, 2)
\end{verbatim}

Since e-graph rewrite patterns search on e-classes, this rule is automatically
re-checked when e-classes are merged. In total, there are as many domain
restriction rules as there are combinations of positions in which inputs can
alias: $\sum_{k=2}^{6} \binom{k}{2} = 35$ rules.

\subsection{Functional Decomposition}\label{sec:rewrites:decomp}
