\section{Introduction}\label{sec:intro}
Given the complexity of modern electronic systems, a high degree of automation
is required to develop custom hardware within sensible timelines. At the
highest level, FPGA and ASIC design flows can be split into logical synthesis
and physical synthesis (placement and routing, floorplanning, etc..). This
division of work produces suboptimal designs, and neither are the individual
synthesis steps locally optimal on their own. However, circuit minimization
problems in general are NP-Hard~\cite{logicmin,twolevellogic}, and modern EDA
flows bring compile times down to the human timescale while maintaining
acceptable QoR (quality of results).

With the end of Moore's Law scaling, chip area becomes a tighter constraint,
and logic synthesis is more of a bottleneck. Hence, future synthesis tools will
need to expand the design spaces they explore and find more optimal solutions.
Still, finding provably optimal circuits is computationally intractable. In
this paper, we introduce how FPGA technology mapping can be augmented with
e-graph data structures to find \textit{more} exact solutions, without
significantly increasing compile times.

Technology mapping is the hand-off between logical synthesis and physical
synthesis. It converts the abstract Boolean logic into a network of gates that
belong to the target cell library. For FPGAs, the primary target cell is the
LUT (lookup table). Since every $k$-LUT can be re-programmed to satisfy any $k$
input boolean function, FPGA technology mapping has an unmistakably large
solution space. Whether the circuit is optimized for latency or area, most FPGA
tools approach technology mapping as a graph covering problem~\cite{flowmap,
    daomap, attmap, imap}. In the literature, a group of circuit nodes implemented
by a $k$-LUT is called a $k$-feasible cut of logic, and the generation of all
cuts is called cut enumeration. These structural mapping techniques rely on the
topology of the input circuit, and hence they are prone to \textit{structural
    bias}.

In contrast, functional mappers attempt to decompose the Boolean functionality
into smaller sub-functions which can be realized by $k$-LUTs. Such mappers are
a more exact approach, and often use SAT solvers~\cite{satmap,satmap2} to drive
synthesis. However, exact synthesis tools cannot be scaled past tens of gates.
As a consequence, cut enumeration and functional mapping lie on two different
extremes. The former is faster but limited by the input structure, while the
latter is unbiased but fundamentally unscalable.

For this reason, we propose an e-graph driven technology mapper than can better
span the time-QoR spectrum. Equivalence graphs, referred to as e-graphs, are a
data structure which use union-find operations to compactly represent abstract
equivalence relations. E-graphs are useful as an optimizing compiler framework,
because terms can be iteratively rewritten in a nondestructive fashion. Whereas
typical optimizing compilers apply a greedy sequence of transformation passes,
e-graph driven compilers store all transformed terms in parallel and defer
selection of the best one. Our work seeks to evaluate the suitability of
e-graphs for logic synthesis, specifically technology mapping to FPGAs.

We introduce \shortname{}: a tool for repacking FPGA netlists into more compact
forms---without increasing circuit depth. Our results show many benchmarks, big
and small, which synthesize to significantly fewer LUTs over vendor EDA tools.
To that end, our work makes the following contributions:

\begin{itemize}
    \item We formulate an intermediate language and set of e-graph rewrite rules that can
          explore a range of circuit topologies that heuristic approaches miss.
    \item Upon extraction, \shortname{} can produce a proof of equivalence between the
          optimized form and original input.
    \item We evaluate our compiler against \nbenchmarks{} benchmarks combined from three
          sources: EPFL~\cite{epflbench}, ISCAS'85~\cite{iscasbench}, and
          LGSynth'91~\cite{lgsynthbench}. The results show significant improvements in
          LUT count without increasing circuit depth.
    \item Finally, \shortname{} is packaged as a Verilog-to-Verilog tool that can be
          dropped into existing RTL flows.
\end{itemize}

Before elaborating on our methodology and experimental setup, we first discuss
related ideas in technology mapping and e-graph driven compilers. Then, the
results section illustrates the typical reduction in LUT count our tool
achieves without increasing circuit depth. Lastly, we discuss the future work
of our compiler.