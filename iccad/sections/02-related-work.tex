\section{Related Work}\label{sec:relatedwork}
% Related work todo
% - dsd
\subsection{LUT Packing}\label{sec:relatedwork:fpga}
Broadly speaking, FPGA LUT packing can be divided into architecture-specific
and architecture-nonspecific optimizations. Architecture-specific LUT packing
can reduce routing congestion by more efficiently using intra-CLB routing
resources. Examples include mapping dual-output functions to fractured
LUTs~\cite{fraclut} or using dedicated multiplexers to implement functions with
more than 6 inputs~\cite{ug574}. \todo{mention FF packing}

In contrast, architecture-nonspecific LUT packing is broader as it attempts to
mitigate the structural bias of the input logic in general. As an example,
AGDMap~\cite{adaptdecomp} decomposes simple logic gates with large fanin to
enable the exploration of better graph coverings. However, structural bias can
take on many forms. For instance, FlowMap~\cite{flowmap} cites that the
non-monotone clustering of logic is the fundamental difficulty of LUT-based
technology mapping. In other words, a $k$-feasible cut of logic may contain
subcuts that are \textit{not} $k$-feasible. Overcoming bouts of non-monotone
clustering requires a more elaborate cut-selection algorithm, and our work lays
the foundation for a formal, reasoning-based approach to the problem.

\subsection{E-Graph Superoptimization}\label{sec:relatedwork:egraph}
In recent years, e-graphs and equality saturation have enjoyed renewed
popularity within the compilers field. Several recent works use e-graph driven
superoptimization to improve upon existing EDA tool flows. SEER~\cite{seer}
uses e-graphs to optimize and parallelize the control flow of high-level
synthesis (HLS) programs. IMpress~\cite{impress} also uses e-graphs at the HLS
level, optimizing the datapath of large bit-width multipliers. At a lower
level, ROVER~\cite{rover,roverbl,egraphconstraints} rewrites arithmetic data
paths at the word and bit levels. ROVER straddles the RTL and physical level of
abstraction, making it more general purpose than IMpress. In any case, the work
which is most similar in its goals to ours is E-Syn~\cite{esynth}. E-Syn uses
Boolean algebra to rewrite a circuit with known properties like De Morgan's
laws and the consensus theorem. Ultimately, E-Syn performs its optimizations
during technology-independent synthesis steps, whereas \shortname{} applies as
a post-processing step \textit{after} technology mapping. Furthermore,
\shortname{}'s rewriting system models the netlist in terms of total functions,
rather than as expressions over a Boolean algebra.